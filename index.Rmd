---
title: "Bioc2023: extraChIPs Package Demonstration"
author:
- name: Stevie Pederson
  affiliation: 
  - Black Ochre Data Laboratories, Telethon Kids Institute, Adelaide, Australia
  - Dame Roma Mitchell Cancer Researc Laboratories, University of Adelaide
  - John Curtin School of Medical Research, Australian National University
  email: stephen.pederson.au@gmail.com
package: extraChIPs
bibliography: references.bib
output:
  BiocStyle::html_document:
    self_contained: false
abstract: |
  extraChIPs: Package Demo
vignette: |
  %\VignetteIndexEntry{Package Demonstration}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo=FALSE, eval = TRUE}
knitr::opts_chunk$set(
  message = FALSE, warning = FALSE,
  fig.height = 6, fig.width = 8, dev = 'png'
)
```


# Introduction

## Package Introduction

`extraChIPs` was developed to provide key infrastructure for a larger ChIP-Seq workflow comparing binding dynamics across multiple ChIP targets.
The focus is on:

- Differential Signal Detection
- Comparison between ChIP targets or sets of results
- Working with `GRanges` objects containing important values in the `mcols()` element
- Visualisation of Data and Results

The package was developed to utilise *existing* S4 Object Classes and behave in a *tidy-friendly manner*, whilst not being strictly designed under tidy programming guidelines.
Some functions may be analogous to those in existing packages, but the aim is to be simple and intuitive to use, whilst simplifying high-performance analyses.
Previous work by the authors of DiffBind [@DiffBind2012] and csaw [@csaw2016] has been instrumental in the package design, along with the tidyverse [@tidyverse2019] and edgeR [@edgeRQLF2016].

## Data and Workshop Setup

Today's workshop will focus on the `devel` version of the package, which can be installed using

```{r install-bioc, eval = FALSE}
BiocManager::install(
  "extraChIPs", version = "devel", update = FALSE, ask = FALSE
)
```

Alternatively, this can be installed directly from github

```{r install-github, eval = FALSE}
BiocManager::install(
  "smped/extraChIPs", ref = "devel", update = FALSE, ask = FALSE
)
```

Additional packages required can be installed as follows:

```{r install-extra, eval=FALSE}
pkg <- c(
  "rtracklayer", "tidyverse", "glue", "plyranges", "Rsamtools", "csaw", 
  "edgeR","patchwork"
)
BiocManager::install(pkgs = pkg, update = FALSE, ask = FALSE)
```

```{r packages}
library(tidyverse)
library(glue)
library(plyranges)
library(extraChIPs)
library(Rsamtools)
library(csaw)
library(edgeR)
library(rtracklayer)
library(patchwork)
theme_set(theme_bw())
```


Data can be obtained from [here]() and should be placed in a folder called `data` within your current working directory.
This data has been pre-processed [here](https://github.com/smped/PRJNA509779) using the prepareChIPs workflow [@pederson_2023], and subset to a region on Chromosome 10 for easier working in today's context.

The two targets in this dataset are the Estrogen Receptor (ER$\alpha$) and the histone mark H3K27ac.
Data has been taken from ZR-75-1 cells cultured in Estrogen (E2) or Estrogen + Dihydrotestosterone (E2DHT), and was first published by researchers from the Dame Roma Mitchell Cancer Research Laboratories [@Hickey2021-mz]

The sample sheet for the ER$\alpha$ samples can be setup by copying the following code.
As can be seen, we have three samples from the E2 (baseline) group with three more treated by the addition of DHT.

```{r er_samples}
treat_levels <- c("E2", "E2DHT")
er_samples <- tibble(
  accession = paste0("SRR831518", seq(0, 5)),
  target = "ER",
  treatment = factor(rep(treat_levels, each = 3), levels = treat_levels)
)
er_samples
```

We'll also setup colours for each treatment for consistent visualisations throughout the analysis

```{r treat-colours}
treat_colours <- setNames(c("steelblue", "red3"), treat_levels)
```

Finally, we'll define a `Seqinfo` object just for today's data.

```{r sq}
sq <- Seqinfo(
  seqnames = "chr10", seqlengths = 135534747, isCircular = FALSE, 
  genome = "hg19"
)
```



# Core Infrastructure

## `*MC()` Functions

Many functions exist for combining sets of ranges, such as `reduce()`, `intersect()`, `setdiff()` etc, however these have been extended in `extraChIPs` to `reduceMC()`, `intersectMC()`, `setdiffMC()` and `unionMC()` as well as tidy-aligned functions `chopMC()` and `distinctMC()`.
This group of functions behaves identically to the core `GenomicRanges` versions, but retains data in the `mcols` element.
These are used internally by many functions within the package, but also have many stand-alone uses.

Define a simple set of ranges, with ids in the `mcols`

```{r define0x}
x <- GRanges(c("chr1:1-10", "chr1:6-12"))
x$id <- c("range1", "range2")
x
```

When calling `reduce()` we lose all `mcols` information.

```{r reduce}
reduce(x)
```

These are retained when calling `reduceMC`

```{r reduce-mc}
reduceMC(x)
```

All other functions behave in a similar manner

```{r other-mc}
y <- GRanges(c("chr1:11-15"))
intersect(x, y)
intersectMC(x, y)
setdiff(x, y)
setdiffMC(x, y)
union(x, y)
unionMC(x, y)
```


## `tibble` Coercion

As this package is also designed to play well with the `tidyverse` the functions `as_tibble()` and `colToRanges()` have been introduced.
When coercing to a `tibble`, the `GRanges` element is coerced to a character vector.

```{r as-tibble}
tbl <- as_tibble(x)
tbl
```

The tibble can be returned to the more conventional set of columns by setting `rangeAsChar = FALSE`

```{r range-as-char}
as_tibble(x, rangeAsChar = FALSE)
```

Additional methods have been implemented for easy coercion of `DataFrame`, `GInteractions`, `Seqinfo`, `SummarzedExperiment` and `TopTags` objects

Coercion is implemented from `tibble` to `GRanges` using `colToRanges()`

```{r col-to-ranges}
colToRanges(tbl, var = "range")
```

Whilst the `seqinfo` is clearly lost in the reverse coercion, `colToRanges()` also allows for moving a `GRanges` object within the `mcols` element to be set as a new set of ranges.
In this case, the `seqinfo` will be retained.

# Working With Peaks

## Import and Visualisation

Broad and Narrow Peak files as output by peak callers such as `macs2 callpeak` [@Zhang2008-ms] can be imported using `importPeaks()`.
This will always return a `GRangesList` for simple downstream analysis.
If importing `narrowPeak` files, the peak centre can be automatically added.

```{r import-peaks}
fl <- glue("data/ER/{er_samples$accession}_peaks.narrowPeak")
peaks <- importPeaks(fl, seqinfo = sq, centre = TRUE)
names(peaks) <- str_remove_all(names(peaks), "_peaks.narrowPeak")
```

(Names can also be set using `glue` syntax, however the above is generally more easily comprehended at first glance.)

Blacklisted regions and grey-listed regions are also able to be applied during import.
Blacklisted regions are usually available from [public sources](https://github.com/Boyle-Lab/Blacklist/tree/master/lists), whilst grey-listed regions are derived from a relevant input.

These have also been provided and can be loaded separately then combined.

```{r black-grey-lists}
bg_list <- file.path(
  "data", "annotations", c("chr10_blacklist.bed", "chr10_greylist.bed")
) %>% 
  lapply(import.bed, seqinfo = sq) %>% 
  lapply(granges) %>% 
  GRangesList() %>% 
  unlist() %>% 
  sort()
peaks <- importPeaks(fl, seqinfo = sq, centre = TRUE, blacklist = bg_list)
names(peaks) <- str_remove_all(names(peaks), "_peaks.narrowPeak")
```

Now we've loaded our peaks and excluded peaks within unreliable ranges, one of the first tasks might be to check how similar our replicates are.
This can easily be performed using `plotOverlaps()`


```{r plot-overlaps, fig.cap = "Overlapping peaks between all replicates"}
plotOverlaps(peaks, set_col = treat_colours[er_samples$treatment])
```

`plotOverlaps()` calls the plotting functions provided by `ComplexUpset::upset()` [@ComplexUpset2020] and as such, can handle any additional parameters which are understood by this function.

```{r plot-overlaps2, fig.cap = "Overlapping peaks, showing only intersections with 10 or more members and retaining the original sample ordering"}
plotOverlaps(
  peaks, .sort_sets = FALSE, 
  set_col = treat_colours[er_samples$treatment], n_intersections = 10
)
```

## Consensus Peaks

The next step might be to form a set of consensus peaks for each treatment.
Just forming a set of consensus peaks for the E2 samples can be done manually

```{r make-consensus}
makeConsensus(peaks[1:3])
```

In reality, we may prefer to only retain peaks found in 2/3 samples and we can do this by setting `p = 2/3`.
We can also also `makeConsensus` to retain one or more columns from the original peaks using `var = `

```{r make-consensus-p}
makeConsensus(peaks[1:3], p = 2/3, var = "centre")
```

By default, this takes the union of the ranges called as peaks in each sample.
We may instead prefer to just retain regions *covered* in $\geq$ 2/3 samples.
Not that whilst we have the same number of ranges here, the ranges are tighter.

```{r make-consensus-coverage}
makeConsensus(peaks[1:3], p = 2/3, method = "coverage")
```

In order to make consensus peaks for each condition, we can split by treatment group, then use a simple `lapply()` trick, to work with both treatment groups together.

```{r lapply-consenses}
cons_peaks <- peaks %>% 
  split(f = er_samples$treatment) %>% 
  lapply(makeConsensus, p = 2/3, var = "centre") %>% 
  lapply(select, centre) %>% 
  lapply(mutate, centre = vapply(centre, mean, numeric(1))) %>% 
  GRangesList()
```

A lot happened in that code chunk, so let's break it down

1. We split samples based on the treatment (`split(f = er_samples$treatment)`), then
2. Identified consensus peaks within each treatment found in 2/3 samples, retaining the peak centre (`lapply(makeConsensus, p = 2/3, var = "centre")`)
3. Subset the `mcols` to only retain the peak centre (`lapply(select, centre)`). 
4. The previous step returned centre estimates as a `NumericList`, so we took the mean of these for each consensus peak
5. We coerced to a `GRangeList`

Now we can compare our two treatment conditions using `plotOverlaps()` again, which will return a Venn Diagram when passing a `GRangesList` of length 2.

```{r plot-cons-overlap, fig.width=6, fig.cap = "Overlaps betwen consensus peaks specific to each treatment group"}
plotOverlaps(cons_peaks, set_col = treat_colours)
```

Finally, we can form a set of "union" peaks, defined as those within a consensus peak for either treatment group.

```{r union-peaks}
union_peaks <- makeConsensus(cons_peaks, var = "centre") %>% 
  mutate(centre = vapply(centre, mean, numeric(1)) %>% round(0))
```

## Mapping Peaks to Regulatory Regions

Now we have detected our ranges where ER$\alpha$ appears to have bound, we might wish to find which genes are likely targets and what type of genomic feature is associated with each range.
First let's define some genomic regions.

A Gencode GTF has been provided in data, restricted to the regions of chr10 we're working with today.
We can load this then, split based on the feature type, giving a `GRangesList` with gene, transcript and exon-level features.

```{r load-gtf}
gtf <- file.path(
  "data", "annotations", "gencode.v43lift37.chr10.annotation.gtf.gz"
) %>% 
  import.gff() %>% 
  split(.$type)
seqinfo(gtf) <- sq
```

The function `defineRegions()` enables us to define 1) Promoter, 2) Upstream Promoter, 3) Intron, 4) Exon, 5) Proximal Intergenic and 6) Distal Intergenic Regions.
The distances for these regions can be specified by the user, but here we'll just use the defaults.

```{r regions}
regions <- defineRegions(
  genes = gtf$gene, transcripts = gtf$transcript, exons = gtf$exon
)
regions
```

Now we can assign these to the peaks using `bestOverlap`

```{r best-overlap}
union_peaks$region <- bestOverlap(union_peaks, regions)
union_peaks
```

When providing a `GRangesList` the overlaps are defined by the element names.
Alternatively, we could pass a `GRanges` object and specify the name from the `mcols` element we wish to us.

```{r better-overlap}
union_peaks$region <- bestOverlap(union_peaks, unlist(regions), var = "region")
union_peaks
```

Let's set these as a factor in order as contained in the original set of regions.

```{r set-region-levels}
reg_levels <- vapply(regions, function(x) x$region[1], character(1))
union_peaks$region <- factor(union_peaks$region, levels = reg_levels)
```


We can check the distribution of our peaks against these regions using `plotPie()`

```{r plotpie-default, fig.cap = "Distribution of peaks within defined regulatory regions"}
region_colours <- hcl.colors(6, "viridis", rev = TRUE)
names(region_colours) <- reg_levels
plotPie(union_peaks, fill = "region") +
  scale_fill_manual(values = region_colours)
```

The labels for `plotPie()` use the `glue` syntax, lending enormous flexibility to what can be placed here.
Whist the defaults are hopefully useful, in the code below. we'll modify these to wrap the text using `str_wrap()` and add `n =` to the peak numbers.

```{r plotpie-labels, fig.cap = "Distribution of peaks with manually tweaked segment labels"}
plotPie(
  union_peaks, fill = "region", total_size = 5,
  cat_glue = "{str_wrap(.data[[fill]], 15)}\nn = {comma(n, 1)}\n({percent(p, 0.1)})"
) +
  scale_fill_manual(values = region_colours)
```


Finally, we might wish to know which genes are likely targets for each peak.
`mapByFeature()` uses a mapping strategy which maps peaks/ranges to genes differently depending on which type of feature they overlap.

1. Ranges overlapping a *promoter* are only assigned to the gene(s) associated with that promoter
2. Ranges overlapping an *enhancer* are mapped to all gene within a given distance
3. Ranges overlapping a *long-range interaction* are mapped to genes at both ends of the interaction
4. Remaining ranges are mapped to the *nearest gene* within a given distance

```{r add-genes}
union_peaks <- mapByFeature(
  union_peaks, genes = gtf$gene, prom = regions$promoter
)
union_peaks %>% filter(str_detect(region, "^Promoter"), !E2)
```


# Differential Signal Detection

## Using Fixed-Width Windows

### Reading In Counts

Now that we've defined our set of peaks present under either condition, we can use these to perform a differential signal analysis.
Existing packages such as `DiffBind` use fixed-width regions to minimise bias from variable sized regions.
Using `extraChIPs` we can define these ranges using our peak centres that we've carried forward.

```{r centred-peaks}
centred_peaks <- union_peaks %>% 
  mutate(
    centre = paste0(seqnames, ":", centre),
    union_peak = granges(.)
  ) %>% 
  colToRanges(var = "centre") %>% 
  resize(width = 400, fix = "center") 
```

In the above, we've 1) created a new range from the centre-points, 2) placed the original range as a new column in the `mcols` element, 3) moved the centred range to being the primary range using `colToRanges()`.
From there, we've resized to a standard width of 400bp.
We can now use these ranges to count alignments across our set of samples.
The bam files should be in the `data` directory and can be formed into a `BamFileList`, before being passed to `regionCounts()` from `csaw`.
This will return a `RangedSummarizedExperiment` with totals from the entire bam file in the `totals` column of the `colData` element

```{r load-er-counts}
er_bfl <- file.path("data", "ER", paste0(er_samples$accession, ".bam")) %>% 
  BamFileList() %>% 
  setNames(er_samples$accession)
er_se <- regionCounts(er_bfl, centred_peaks, ext = 200)
seqinfo(er_se) <- sq
er_se
colData(er_se)
```

Let's ensure our sample metadata is consistent between this object and `er_samples`

```{r modify-er-coldata}
colData(er_se) <- colData(er_se) %>% 
  as_tibble(rownames = "accession") %>% 
  left_join(er_samples) %>% 
  as("DataFrame")
```

The use of fixed-width and centred ranges minimises bias which might be between samples with different signal characteristics, but importantly, the counts from these centred ranges as simply our *proxy* for the ranges defined earlier.
Again, using `colToRanges()` we can place our original set of union peaks back as the `GRanges` element underlying the `RangedSummarizedExperiment`.

```{r reassign-union-peaks}
rowRanges(er_se) <- rowRanges(er_se) %>% 
  colToRanges(var = "union_peak") %>% 
  select(region, starts_with("gene"))
```


### Visualising Data

Now that we've loaded counts, we can explore and visualise them in several ways.
The first might be to check the count distributions, using `plotAssayDensities()`.

```{r plot-er-dentisites, fig.cap = "Densities of raw counts for all centred regions, using the 'log1p' transformation"}
plotAssayDensities(er_se, trans = "log1p", colour = "treatment") +
  scale_colour_manual(values = treat_colours)
```

We might follow this with a PCA

```{r plot-er-pca, fig.cap = "PCA plot for all ER samples"}
plotAssayPCA(
  er_se, trans = "log1p", colour = "treatment", label = "accession"
) +
  scale_colour_manual(values = treat_colours)
```

An important QC metric as an RLE plot which finds the median value across all samples & ranges to identify any samples with consistently higher/lower or divergent signal.
By way of example, we may wish to normalise out counts using logCPM values for this purpose, so let's perform this step first

```{r plot-er-rle, fig.cap = "RLE plot for all ER samples"}
assay(er_se, "logCPM") <- cpm(
  assay(er_se, "counts"), lib.size = er_se$totals, log = TRUE
)
plotAssayRle(er_se, assay = "logCPM", fill = "treatment") +
  geom_hline(yintercept = 0, linetype = 2) +
  scale_fill_manual(values = treat_colours) 
```

A problem sometimes faced in ChIP-Seq data which is less prevalent in RNA-Seq data that counts may be drawn from different distributions under different treatments, as DNA-binding is either increased or decreased globally by a treatment.
We can simply view all samples summarised by treatment group in order to highlight any possible global differences.

```{r plot-er-rle-grouped, fig.cap = "RLE plot for ER samples grouped by treatment."}
plotAssayRle(er_se, assay = "logCPM", fill = "treatment", by_x = "treatment") +
  geom_hline(yintercept = 0, linetype = 2) +
  scale_fill_manual(values = treat_colours) 
```

### Differential Signal Analysis

Performing Differential Signal Analysis is now simple using `fitAssayDiff()`, which offers two methods of analysis: `method = "qlf"` (default) or `method = "lt"`.
Respectively, these apply Quasi-Likelihood fits using edgeR [@Lund2012-xo], as is appropriate for count data, or `limma-trend` [@Law2014-xq] if fitting on the log-transformed, (e.g.  `logCPM`) data.
By default, this will return a `SummarizedExperiment` with results added to the `rowRanged()`/`rowData()` element.
Alternatively, we can return a `GRanges` object by setting `asRanges = TRUE`

```{r er-initial-fit}
X <- model.matrix(~treatment, data = colData(er_se))
er_results <- fitAssayDiff(er_se, design = X, asRanges = TRUE)
```

The default normalisation is to use Library Size as contained in the `totals` column.
However, by setting `lib.size = NULL` then `colSums()` will be used if this is considered more suitable.
Additionally, any of the normalisation methods available in `edgeR::calcNormFactors()` can be applied.
Providing a column name to the `groups` argument will also normalise within groups, instead of across the entire dataset.

```{r er-tmm}
er_results <- fitAssayDiff(er_se, design = X, norm = "TMM", asRanges = TRUE)
```

Finally, a range-based H~0~ [@McCarthy2009-qf] can be applied by provided a fold-change value below which we consider change to be uninteresting, and we can also automatically add Differential Signal status.

```{r er-lambda}
er_results <- fitAssayDiff(
  er_se, design = X, norm = "TMM", asRanges = TRUE, fc = 1.2
) %>% 
  addDiffStatus()
arrange(er_results, PValue)
```

Given these results are in a `GRanges` object, we can produce an MA-plot using conventional `ggplot2` approaches.

```{r er-plotma, fig.cap = "MA-plot for ERa analysis using fixed-width windows, TMM normalisation and setting 20% as the range beyond which we consider diferential signal to be of interest."}
status_colours <- c(
  Undetected = "grey70", Unchanged = "grey30", 
  Decreased = "blue", Increased = "red"
)
er_results %>% 
  as_tibble() %>% 
  ggplot(aes(logCPM, logFC)) +
  geom_point(aes(colour = status)) +
  geom_smooth(method = "lm", se = FALSE) +
  scale_colour_manual(values = status_colours)
```

### Visualising Results

Additionally, we might like to compare Differential Signal Status against the regions we defined earlier and 
`plotSplitDonut()` is well suited to this.
A key advantage of `plotSplitDonut()` is the ability to specify inner and outer palettes separately

```{r plotsplitdonut-default, fig.cap = "Split-Donut plot showing distribution of peaks with diferential signal"}
er_results %>% 
  plotSplitDonut(
    inner = "region", outer = "status",
    inner_palette = region_colours, outer_palette = status_colours
  )
```

Once again, labels are controlled using the `glue` syntax and segments are able to be exploded based on matches to a regular expression

```{r plotsplitdonut-labels, fig.cap = "Split-Donut plot exploding segments with evidence of differential signal, and modifying segment labels"}
er_results %>% 
  plotSplitDonut(
    inner = "region", outer = "status",
    inner_palette = region_colours, outer_palette = status_colours,
    inner_glue = "n = {n}", inner_min_p = 0, inner_label_size = 3.5,
    outer_glue = "{str_wrap(.data[[inner]], 15)}\n{.data[[outer]]}\nn = {n}",
    outer_min_p = 0, outer_max_p = 0.03,
    explode_outer = "Increased|Decreased", explode_r = 0.3
  )
```

## Using Sliding Windows

`fitAssayDiff()` is agnostic to sliding or fixed-width windows.
Whilst fixed-width windows are relatively simple conceptually, sliding windows offer other advantages such as being able to manage data where signal comes from genomic regions which are highly variable in width, such as histone marks like H3K27ac.
Sliding window analysis is well-implemented in `csaw`, however `extraChIPs` offers the additional ability to combine ranges using asymptotically correct *harmonic mean p-value* [@Wilson2019-ln].
The step of moving from genomic windows to a subset of windows which we can confidently assume contain signal is also able to be managed by `extraChIPs` using `dualFilter()`.

For this section of the analysis, we'll use data for the histone mark H3K27ac from the same cell type under the same two conditions (E2 + E2DHT).
A new sample metadata sheet can be formed using the following, and we'll immediately for the `BamFileList` for reading in counts.

```{r h3k-samples}
h3k_samples <- tibble(
  accession = paste0("SRR83151", seq(86, 91)),
  target = "H3K27ac",
  treatment = c(factor(rep(treat_levels, each = 3), levels = treat_levels))
) %>% 
  bind_rows(
    tibble(accession = "SRR8315192", target = "Input")
  )
h3k_bfl <- file.path(
  "data", "H3K27ac", paste0(h3k_samples$accession, ".bam")
) %>% 
  BamFileList() %>% 
  setNames(h3k_samples$accession)
```

### Defining Windows

Given we're going to use sliding windows, we can use a smaller window size and need to set a step-size for 'sliding' along the genome.
Whilst there are no hard and fast rules, for a histone marks, window sizes of 150bp sliding in steps of 50bp may be a good choice.


```{r set-windows}
win_size <- 150
win_step <- 50
```

The example dataset for today can be easily managed on a laptop, however, it should be noted that for a full-scale dataset, large amounts of RAM are required, and this process may take considerable time.
In the following we define some key parameters for passing to `csaw::windowCounts()`, where we restrict counting to `chr10`, provide out black and grey-lists and let the function know that these are all single-end reads.

From there, we perform the counts using the window step & size as defined above, extending each read to represent a full DNA fragment of 200nt, and discarding any regions with fewer than 1 read/sample.

```{r wincounts}
rp <- readParam(pe = "none", restrict = "chr10", discard = bg_list)
wincounts <- windowCounts(
  bam.files = h3k_bfl,
  spacing = win_step, width = win_size, ext = 200,
  filter = length(h3k_bfl),
  param = rp
)
seqlevels(wincounts) <- seqlevels(sq)
seqinfo(wincounts) <- sq
dim(wincounts)
```

Many of these windows will have counted reads which are essentially background noise, and we wish to exclude these and only retain those which confidently contain signal from our ChIP target.
`extraChIPs` provides a function `dualFilter()` in which a set of guide ranges can be provided where signal is expected.
Thresholds for minimum overall signal, and signal relative to input are set based on retaining a give proportion of reads which overlap these ranges, with lower numbers returning more stringently selected ranges.

A set of guide ranges has been prepared following a similar process to forming union peaks above for ER$\alpha$, and can be loaded then passed to `dualFilter()`.
Again, this dataset is easily handled on a laptop, whilst for a complete genome, considerable amounts of RAM will be required.

```{r filtcounts}
guide_ranges <- file.path("data", "H3K27ac", "H3K27ac_chr10.bed") %>% 
  import.bed(seqinfo = sq)
filtcounts <- dualFilter(
  x = wincounts[,dplyr::filter(h3k_samples, target == "H3K27ac")$accession],
  bg  =  wincounts[,dplyr::filter(h3k_samples, target == "Input")$accession],
  ref = guide_ranges, q = 0.6
)
colData(filtcounts) <- colData(filtcounts) %>% 
  as_tibble(rownames = "accession") %>% 
  left_join(h3k_samples) %>% 
  as("DataFrame")
dim(filtcounts)
```

By default, an additional assay `logCPM` will be added during this step and this can also be used for QC.

```{r plot-filt-assays, fig.height=5, fig.cap = "A) Density plot and B) PCA based on logCPM values from the sliding windows retained after filtering."}
A <- plotAssayDensities(filtcounts, assay = "logCPM", colour = "treatment") + 
  scale_colour_manual(values = treat_colours)
B <- plotAssayPCA(
  filtcounts, assay = "logCPM", colour = "treatment", label = "accession"
) +
  scale_colour_manual(values = treat_colours)
A + B + plot_layout(guides = "collect") + plot_annotation(tag_levels = "A") 
```

Now we can pass our filtered windows to `fitAssayDiff()` as we did previously, however, once we have performed statistical testing on each window, we need to merge windows to obtain our final results.

```{r fit-filtcounts}
X <- model.matrix(~treatment, data = colData(filtcounts))
h3k_all <- fitAssayDiff(filtcounts, norm = "TMM", design = X, asRanges = TRUE)
```

Although we haven't declared in regions as showing differential signal, we can still inspect an MA plot for any unexpected issues in our data

```{r plotma-h3k, fig.cap = "MA plot using all sliding windows retained after the initial filtering step."}
h3k_all %>% 
  as_tibble() %>% 
  ggplot(aes(logCPM, logFC)) +
  geom_point() +
  geom_smooth(se = FALSE)
```

As expected with H3K27ac signal, the total amount of signal obtained under two related conditions is similar and we have a nicely centred plot.

### Merging Windows

Now we can merge overlapping windows to obtain our final results.
Using `extraChIPs` this can be performed using all methods offered by `csaw`, (`?mergeByCol` and `?mergeBySig`) as well as using the asymptotically-exact harmonic mean p-value, which we'll use here.

```{r merge-h3k}
h3k_results <- mergeByHMP(h3k_all, min_win = 2, merge_within = win_size + 1) %>% 
  addDiffStatus()
h3k_results
```

Notice that we have additional columns not returned when using fixed-width windows.
The first three indicate how many original windows were merged, along with how many may have been individually considered as showing differential signal in either direction.
Next to these is the column `keyval_range` which indicates the original window which returned the lowest p-value, or by setting `keyval = "merged"`, will return the range containing all original windows with raw p-values below the harmonic-mean p-value.

Given the harmonic mean involves summing the inverse of raw p-values, these are considered to be weights and the returned values for logCPM and logFC are also weighted averages, using $w_i = \frac{1}{p_i}$ as weights for each windows $i$.
Given this, any MA-plots may appear to show bias, which is in fact due to the weighting strategy used here.
As such the previous figure using all windows prior to merging is the best strategy for identifying any issues with the data

```{r plotma-merged-h3k, fig.cap = "MA plot showing results after merging overlapping windows."}
h3k_results %>% 
  as_tibble() %>% 
  ggplot(aes(logCPM, logFC)) +
  geom_point(aes(colour = status), alpha = 0.7) +
  geom_smooth(method = "lm", se = FALSE) +
  scale_colour_manual(values = status_colours)
```


# Comparing Both Sets Of Results

`extraChIPs` provide additional capacity for comparing between two or more sets of results.
The key structure for this is a `GRangesList`, so let's ensure we have compatible column names, then form a combined object.

```{r both-results}
h3k_results <- h3k_results %>% 
  select(logCPM, logFC, PValue = hmp, FDR = hmp_fdr, status) %>% 
  mutate(region = bestOverlap(., unlist(regions), var = "region")) %>% 
  mapByFeature(genes = gtf$gene, prom = regions$promoter)
both_results <- GRangesList(ER = er_results, H3K27ac = h3k_results) 
```


## Association Between Datasets

Now we have a combined `GRangesList` object, we can plot columns from each element against the other.
If we wish to compare signal in sites where both are detected, we can use `plotPairwise()`, which will also show boxplots of signal for where only one target is detected, alongside those where both targets are detected


```{r plot-pairwise-logcpm, fig.cap = "Comparison of logCPM values when both targets are detected, with boxplots showing the range of values when each target was detected alone, or when both were detected together"}
plotPairwise(both_results, var = "logCPM")
```

Although we only have a handful of sites in our example dataset, one might easily suspect that signal for both targets is higher when both are detected together.

Alternatively, we might wish to see which sites are changing together, or where only one is changing.
This time we'll plot `logFC`, colouring points by the *combined* Differential Signal status in each element, and adding labels from the `gene_name` column.
Labels are only added to the sites in each combined group which are furthest from zero.


```{r plot-pairwise-logFC, fig.cap = "Comparison of logFC values when both targets are detcted, with boxplots showing the range of values when only one target is detected, or when both are detected"}
plotPairwise(
  both_results, var = "logFC", colour = "status", label = "gene_name"
) +
  scale_colour_brewer(palette = "Set1", direction = -1)
```

We can also compare columns by performing an operation somewhat analogous to `pivot_wider` where we find overlapping ranges and add columns from each element to a set of consensus peaks.

```{r}
mapGrlCols(both_results, var = "status") 
```

We can use this to quickly find sites which are of interest in both sets of results, along with their targets

```{r}
both_results %>% 
  mapGrlCols(var = c("region", "status", "FDR"), collapse = "gene_name") %>% 
  filter(
    str_detect(ER_status, "Increased|Decreased"),
    str_detect(H3K27ac_status, "Increased|Decreased")
  )
```


This also makes comparison of sites easy using `plotSplitDonut()` and in the following we'll only show sites where both are detected.

```{r plot-status-donut, fig.cap = "Combined status when both targets are detected together"}
both_results %>% 
  mapGrlCols(var = "status") %>% 
  as_tibble() %>% 
  dplyr::filter(!if_any(ends_with("status"), is.na)) %>% 
  dplyr::rename_with(\(x) str_remove_all(x, "_status")) %>% 
  plotSplitDonut(
    inner = "H3K27ac", outer = "ER",
    inner_palette = status_colours, outer_palette = status_colours,
    inner_glue = "{inner}\n{.data[[inner]]}\n{n}",
    outer_glue = "{outer}\n{.data[[outer]]}\n{n}",
    label_alpha = 0.8, min_p = 0.02,
    explode_inner = "Increased", explode_outer = "Increased", 
    explode_query = "AND", explode_r = 0.3
  )
```

Perhaps we might wish to look at the combined status in reference to the genomic regions we defined previously.
Here, we'll scale the site by width to show results in kb, instead of counting sites.

```{r plot-stauts-region-donut, fig.cap = "Combined status shown by the region, as defined by the best overlap for H3K27ac signal. Regions here are scaled by width and totals shown in kb"}
both_results %>% 
  mapGrlCols(var = c("region", "status")) %>% 
  as_tibble(rangeAsChar = FALSE) %>% 
  dplyr::filter(!if_any(ends_with("status"), is.na)) %>% 
  mutate(
    ER_status = fct_relabel(ER_status, \(x) paste("ER", x)),
    H3K27ac_status = fct_relabel(H3K27ac_status, \(x) paste("H3K27ac", x)),
    combined = fct_cross(ER_status, H3K27ac_status, sep = "\n")
  ) %>% 
  plotSplitDonut(
    scale_by = "width",
    inner = "H3K27ac_region", outer = "combined",
    inner_palette = region_colours,
    total_glue = "{comma(N)}kb",
    inner_glue = "{str_wrap(.data[[inner]], 15)}\n{comma(n, 1)}kb",
    outer_glue = "{.data[[outer]]}\n{comma(n, 0.1)}kb",
    outer_min_p = 0.01, #outer_max_p = 0.02,
    explode_outer = "(Inc|Dec).+(Inc|Dec)", explode_r = 0.4,
    label_alpha = 0.7
  )
```


## Regions in Context

As well the above strategies for inspecting results, looking directly at the sites using a genome browser is a common strategy.
`extraChIPs` provides the function `plotHFGC()` which enables us to take a genome level viewpoint of any 1) HiC Interactions, 2) Features, 3) Gene Models and 4) Coverage.
All tracks are optional and will be displayed in this order when provided using the various track types provided by `Gviz` [@gviz].
In order to use this approach to scan through our results choosing one ranges at a time, let's define the elements that we have starting with our genomic regions, which we would consider to be a set of genomic features.
For this track, we'll need a `GRangesList()` and each element will be filled a different colour, meaning we'll need a matching vector of colours.
We already have both of these from earlier on our workflow, but we will need to change the names on our colour vector

```{r rename-region-colours}
names(region_colours) <- names(regions)
```

Next we'll setup our gene models in the format that `Gviz` is familiar with, using the `exons` element from our GTF annotations.

```{r define-gee-models}
gene_models <- gtf$exon %>% 
  select(
    type, gene = gene_id, exon = exon_id, transcript = transcript_id, 
    symbol = gene_name
  )
```

This leaves coverage as our final track, or set of tracks.
`plotHFGC()` takes `BigWigFileList` objects for coverage and if passing a single `BigwigFileList`, each element will be drawn on a separate track.
For our results we have both ER and H3K27ac so a more informative plot might be to overlay the two treatments in a single track for each target.
To facilitate this, we need a *named* list of `BigwigFileList` objects and a matching *named* list of colours.
In each of our data directories we have summarised coverage for E2 and E2DHT

```{r define-bwfl}
targets <- c("ER", "H3K27ac")
bwfl <- list(
  ER = file.path("data", "ER", glue("{treat_levels}_cov_chr10.bw")),
  H3K27ac = file.path("data", "H3K27ac", glue("{treat_levels}_cov_chr10.bw"))
) %>% 
  lapply(setNames, treat_levels) %>% 
  lapply(BigWigFileList)
line_colours <- lapply(bwfl, function(x) treat_colours[names(x)])
```

Now we have our track setup, we'll load the cytogenetic bands provided with `extraChIPs` to ensure we have a band at the top of the plot, although this too is optional.

```{r load-cytobands}
data("grch37.cytobands")
```

And finally, let's select our first range as the most highly ranked site for change ER binding, which also appears to show an increase in H3K27ac signal

```{r choose-sig-ranges}
gr <- both_results %>% 
  mapGrlCols(
    var = c("region", "status", "FDR"), collapse = "gene_name"
  ) %>% 
  arrange(ER_FDR) %>% 
  .[1]
```

Now we pass all of these to `plotHFGC()` zooming out a little to try and get some kind of wider context.

```{r plot-hfgc-default, fig.cap = "Default plot from plotHFGC showing both ER and H3K27ac signal on separate tracks, with the two treatment groups overlaid as separately coloured lines."}
plotHFGC(
  gr, cytobands = grch37.cytobands, 
  features = regions, featcol = region_colours,
  genes = gene_models, genecol = "wheat", 
  coverage =  bwfl, linecol = line_colours,
  zoom = 10
)
```

One helpful feature of is the ability to annotate our coverage tracks to indicate statistical significance.
If we simply split our initial set of results into `GRangesList` objects based on their status, we can use these to add coloured bars above our coverage tracks to denote that signal was detected there, and what the results from analysis were.
We can simply pass our vector of status colours that we've already defined for these


```{r cov-annot}
cov_annot <- list(
  ER = splitAsList(er_results, er_results$status),
  H3K27ac = splitAsList(h3k_results, h3k_results$status)
)
```

Now let's add these annotations and tweak the appearance of the plot

```{r plot-hfgc-final, fig.cap = "Customised output from plotHFGC, adding annotations for each site as well as tweaking the labels and font sizes"}
plotHFGC(
  gr, cytobands = grch37.cytobands, 
  features = regions, featcol = region_colours, featstack = "dense",
  genes = gene_models, genecol = "wheat",
  coverage =  bwfl, linecol = line_colours,
  annotation = cov_annot, annotcol = status_colours,
  zoom = 10, featsize = 2, title.width = 0.9, 
  cex.axis = 1, cex.title = 1, rotation.title = 90,  fontsize = 12
)
```

Just like we were able to provide a separate `BigWigFileList` to indicate separate tracks for our targets, we can use a similar strategy for the genes and features tracks.

1. A `GRangesList` of gene will draw each element on a separate track. This may be useful for indicating results from a Differential Gene Expression analysis by plotting up-regulated and down-regulated genes on separate tracks in different colours
2. Passing a *named* list of `GRangesList` objects to the features track will add each element of the list as a separate tracks. In this way you may wish to add multiple features, such as a `chromHMM` track along with CTCF or other known binding sites.

## Profile Heatmaps

A final way of visualising results may be to draw a Profile Heatmap, where we show coverage or fold-enrichment over background in the surrounding regions.
Instead of separating our `BigWigFileList` into separate tracks, let's just use a single `BigWigFileList` with coverage for both ER and H3K27ac.

```{r profile-bwfl}
profile_bwfl <- bwfl %>% 
  lapply(path) %>% 
  unlist() %>% 
  setNames(str_replace_all(names(.), "\\.", " ")) %>% 
  BigWigFileList()
```

Given we only have a small dataset, let's just choose the top 20 sites by logFC in the ER dataset, and draw Profile Heatmaps for both targets.
We first make a call to `getProfileData()` which smooths the data into bins around the site

```{r profile-data}
er_sig <- arrange(er_results, -logFC)[1:20]
pd <- getProfileData(profile_bwfl, er_sig)
```

We can now pass this to `plotProfileHeatmap()` and can use any of the categorical columns in the original set of ranges to facet our results.
Here we'll facet by status in the ER dataset, which will also draw lines in separate colours.

```{r plot-profile-heatmaps, fig.cap = "Profile Heatmap for the 20 most highly ranked sites for increased ER binding. Ranges are centred around the ER binding patterns. The double peak seen earlier in the output from plotHFGC is at the top of the first panel.`"}
plotProfileHeatmap(pd, "profile_data", facetY = "status") +
  scale_colour_manual(values = status_colours) +
  scale_fill_gradient(low = "white", high = "red") +
  labs(fill = "logCPM")
```

A complete dataset would provide a far cleaner set of results, but we can still see the general increases in ER signal and how these relate to H3K27ac signal.


# References {.unnumbered}


# Session info

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
