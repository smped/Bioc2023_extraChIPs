---
title: "Bioc2023"
subtitle: "extraChIPs: Package Demonstration"
author: "Stevie Pederson"
date: "2023-08-03"
date-format: long
title-slide-attributes:
    data-background-color: "#3c3c44"
    data-background-image: https://raw.githubusercontent.com/Bioconductor/BiocStickers/devel/extraChIPs/extraChIPs.png
    data-background-opacity: "20%"
    data-background-size: "35%"
    data-background-position: "50% 50%"
editor: source
format: 
  revealjs:
    bibliography: references.bib
    theme: [custom.scss]
    code-line-numbers: false
    width: 1024
    height: 768
    sansfont: Times New Roman
    logo: assets/bodl_logo_white_background.jpg
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  message = FALSE, warning = FALSE, echo = TRUE
)
```


# Introduction {background-color="#3c3c44"}

```{r packages, echo = FALSE}
library(tidyverse)
library(extraChIPs)
library(glue)
library(rtracklayer)
library(plyranges)
```


## Who Am I?

- Postdoctoral Bioinformatician at Black Ochre Data Laboratories
    + Telethon Kids Institute, Adelaide, Australia
    + Traditional lands of the Kaurna people
- Improving health outcomes for Indigenous Australians
- 1400-strong patient cohort
    + Genomics, Epigenomics, Transcriptomics, Proteomics etc

## Who Am I?

- Previously in Dame Roma Mitchell Cancer Research Laboratories
    + Integrating multiple ChIP targets across multiple cell lines
    + Dynamics of AR activation with DHT (or SARMs)
    + Often with HiC + RNA-Seq
- Led to the devlopment of `extraChIPs`
    
. . .

- Also the developer/maintainer of `ngsReports` ![](https://raw.githubusercontent.com/Bioconductor/BiocStickers/devel/ngsReports/ngsReports.png){width="20%"}

## Why `extraChIPs`

- Filled several gaps between `DiffBind` [@DiffBind2012] and `csaw` [@csaw2016]
- Simplify detection of Differential Signal
- Enable easier comparison across multiple targets
- Key visualisation tools, core infrastructure + simplified workflows
- All processed designed for existing object classes:
    + `GRanges`, `GRangesList`, `SummarizedExperiment`
- Hopefully useful well beyond ChIP-Seq (DNA-methylation, ATAC-Seq etc)

. . . 

- Built to enable the GRAVI snakemake workflow:
    + Gene Regulatory Analysis using Variable Inputs

# Core Infrastructure {background-color="#3c3c44" background-image=https://raw.githubusercontent.com/Bioconductor/BiocStickers/devel/extraChIPs/extraChIPs.png background-size="35%" background-opacity="0.2"}

## *MC Functions

- Existing functions `reduce`, `setdiff`, `intersect`, `union`
    + All will drop information in the `mcols` element
- `reduceMC`, `setdiffMC`, `intersectMC` and `unionMC`
    + Will retain all information in `mcols` element
- Also introduces `chopMC` and `distinctMC`
    + Based on `tidyverse` functions [@tidyverse2019]
- Regularly used internally

## reduceMC

```{r reduce}
#| echo: 3
x <- GRanges(c("chr1:1-10", "chr1:6-12"))
x$id <- c("range1", "range2")
x
```

. . . 

```{r, echo = TRUE}
reduce(x)
```

. . .

```{r, echo =TRUE}
reduceMC(x)
```

## `tibble` Coercion

- `GRanges` can be coerced to `tibble` objects
- Ranges are coerced to a `character` column
    
```{r}
tbl <- as_tibble(x)
tbl
```

- `rangeAsChar = FALSE` will produce same columns as `as.data.frame`

```{r}
as_tibble(x, rangeAsChar = FALSE)
```

## Coercing `tibble` objects back to `GRanges`

```{r}
tbl
colToRanges(tbl, var = "range")
```


- Seqinfo objects can also be passed via this function

## `colToRanges()`

- `colToRanges` also enables `GRanges` objects in the `mcols` element to become the 'backbone' ranges

```{r}
x$centre <- GRanges(paste0("chr1:", c(5, 10)))
x
colToRanges(x, var = "centre")
```

## `defineRegions()`


```{r load-gtf, echo = FALSE}
sq <- Seqinfo(
  seqnames = "chr10", seqlengths = 135534747, isCircular = FALSE, 
  genome = "hg19"
)
gtf <- file.path(
  "data", "annotations", "gencode.v43lift37.chr10.annotation.gtf.gz"
) %>% 
  import.gff() %>% 
  split(.$type)
seqinfo(gtf) <- sq
```

```r
defineRegions(
  genes,
  transcripts,
  exons,
  promoter = c(2500, 500),
  upstream = 5000,
  intron = TRUE,
  proximal = 10000,
  simplify = FALSE,
  cols = c("gene_id", "gene_name", "transcript_id", "transcript_name"),
  ...
)
```

- Genomic Regions can be defined *hierachically* using a supplied gtf
- 1) Promoters; 2) Upstream Promoters; 3) Exons; 4) Introns; 5) Proximal Intergenic; and 6) Distal Intergenic
    + Exons/Introns can be collapsed into 'Gene Body' (`intron = FALSE`)
    + Intergenic Regions can also be merged  (`proximal = 0`)
- All distances are able to be set manually


## `defineRegions()`

```{r}
regions <- defineRegions(
  genes = gtf$gene, transcripts = gtf$transcript, exons = gtf$exon
)
regions
```



# Working With Peaks  {background-color="#3c3c44" background-image=https://raw.githubusercontent.com/Bioconductor/BiocStickers/devel/extraChIPs/extraChIPs.png background-size="35%" background-opacity="0.2"}

```{r define-er-samples, echo = FALSE}
treat_levels <- c("E2", "E2DHT")
er_samples <- tibble(
  accession = paste0("SRR831518", seq(0, 5)),
  target = "ER",
  treatment = factor(rep(treat_levels, each = 3), levels = treat_levels)
)
treat_colours <- setNames(c("steelblue", "red3"), treat_levels)
```

## Importing Peaks

```r
importPeaks(
  x,
  type = c("narrow", "broad"),
  blacklist,
  seqinfo,
  pruning.mode = c("coarse", "error"),
  sort = TRUE,
  setNames = TRUE,
  glueNames = "{basename(x)}",
  centre = FALSE,
  nameRanges = TRUE,
  ...
)
```

- Will return a `GRangesList`
- Only chromosomes/scaffolds within the `seqinfo` object will be returned
- Peak Centres can be automatically added for `narrowPeak` files

## Importing Peaks

```{r}
fl <- glue("data/ER/{er_samples$accession}_peaks.narrowPeak")
peaks <- importPeaks(fl, seqinfo = sq, centre = TRUE)
names(peaks) <- er_samples$accession
peaks
```

## `plotOverlaps()`

```{r plot-overlaps}
plotOverlaps(peaks, set_col = treat_colours)
```

- Calls `ComplexUpset::upset()` if n >= 3 (otherwise `VennDiagram::draw.pairwise.venn()`)
- All arguments can be passed using `...`

## Consensus Peaks

- By default, the union of ranges will be returned
- Any, or all columns can also be returned

```{r}
makeConsensus(peaks[1:3], var = "centre", p = 2/3)
```

## Consensus Peaks

- Can also return ranges based on coverage between samples
- Narrower, but consistently 'covered' ranges

```{r}
makeConsensus(peaks[1:3], var = "centre", method = "coverage", p = 2/3)
```

## Mapping Peaks


```{r union-peaks, echo = FALSE}
treatment_peaks <- list(
    E2 = makeConsensus(peaks[1:3], var = "centre", p = 2/3),
    E2DHT = makeConsensus(peaks[4:6], var = "centre", p = 2/3)
) %>% 
    lapply(granges) %>% 
    GRangesList()
union_peaks <- makeConsensus(treatment_peaks)
```

```{r}
union_peaks
```


After finding consensus peaks for both treatments in this dataset (E2, E2DHT):

1. Map to regions using `bestOverlap()`
2. Map to genes using `mapByFeature()`

## `bestOverlap()`

```{r}
union_peaks$region <- bestOverlap(union_peaks, unlist(regions), var = "region")
union_peaks
```


## `mapByFeature()`

Maps to genes using ranges separately defined as *promoters*, *enhancers* or *long-range interactions*

```r
mapByFeature(
  gr,
  genes,
  prom,
  enh,
  gi,
  cols = c("gene_id", "gene_name", "symbol"),
  gr2prom = 0,
  gr2enh = 0,
  gr2gi = 0,
  gr2gene = 1e+05,
  prom2gene = 0,
  enh2gene = 1e+05,
  gi2gene = 0,
  ...
)
```

## `mapByFeature()`

```{r}
mapByFeature(union_peaks, genes = gtf$gene, prom = regions$promoter)
```


# Differential Signal Analysis {background-color="#3c3c44"}

## Two approaches to Differential Signal

### Fixed-Width Analaysis

- Highly Comparable to `DiffBind`
- Define a set of fixed-width ranges:
    - Use centres from `importPeaks()` after running `makeConsensus()`
- Count Reads using `csaw::regionCounts()` $\implies$ `RangedSummarizedEperiment`

## Two approaches to Differential Signal

### Sliding Windows

- Based on `csaw`
- Final signal for merged ranges:
    + `csaw` methods: `mergeByCol()`, `mergeBySig()`
    + Return as merged ranges with an additional range as the *key-value range*
- Merge using the Harmonic Mean p-values
    + `mergeByHMP()`
    + logFC and logCPM values are weighted averages based in sliding window p-values
    + Key-value ranges can be 1) Lowest p-value or 2) All ranges below the HMP

## `fitAssayDiff()`

```r
fitAssayDiff(
  x, assay = "counts",
  design = NULL, coef = NULL,
  lib.size = "totals",
  method = c("qlf", "lt"),
  norm = c("none", "TMM", "RLE", "TMMwsp", "upperquartile"),
  groups = NULL,
  fc = 1, lfc = log2(fc),
  asRanges = FALSE,
  offset = NULL,
  null = c("interval", "worst.case"),
  weighted = FALSE,
  ...
)
```

- Calls `edgeR::glmQLFit` methods [@edgeRQLF2016]
- Also calls `limma-trend` if fitting logCPM values [@Law2014-xq]
- Can apply range-based H~0~ [@McCarthy2009-qf]
- Optionally normalise *within treatment groups* (`groups = "treat"`)
- Library sizes can be set as colSums (`lib.size = NULL`)

## `mergeByHMP()`

- Uses the *asmyptotically exact* harmonic-mean p [@Wilson2019-ln]
- Controls the `FDR` similarly to `Simes` method (`csaw`)
- Also has strict `FWER` control (`p_adj_method = "fwer"`)

```r
mergeByHMP(
  x,
  df = NULL,
  w = NULL,
  logfc = "logFC",
  pval = "P",
  cpm = "logCPM",
  inc_cols = NULL,
  p_adj_method = "fdr",
  merge_within = 1L,
  ignore_strand = TRUE,
  min_win = 1,
  keyval = c("min", "merged"),
  ...
)
```

# Comparing Results {background-color="#3c3c44"}


